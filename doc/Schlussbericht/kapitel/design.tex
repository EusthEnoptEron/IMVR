\chapter{Design}

Bei der Entwicklung wurden diverse Design-Entscheidungen gefällt, welche zum Teil bereits in einem Vorprojekt analysiert wurden. Diese sollen in diesem Kapitel aufgelistet und erläutert werden. 

\section{Systemübersicht}
\label{sec:sysoverview}
Um die Applikation zu bedienen, setzt der Anwender die Oculus Rift auf und bewegt sich im von der mitgelieferten Kamera erkennbaren Bereich.

Die Leap Motion wird prinzipiell so verwendet, wie von der Herstellerfirma vorgesehen. Das heisst, diese wird mit dem offiziellen Aufsatz \cite{leap} an der Oculus Rift befestigt, und deckt so den frontalen Sichtbereich des Anwenders ab. Dies lässt sich gut auf Abbildung \ref{fig:systemuebersicht} erkennen.

Ebenfalls erkennbar ist, dass beide Geräte per USB mit dem Host-Computer verbunden sind und Daten an die jeweiligen Services schicken. Diese Services werden durch die in Unity verwendeten Plugins angesteuert, und die ausgewerteten Daten in IMVR verwendet.

\afterpage {
	\begin{figure}[t!]
		\centering
		\includegraphics[width=0.8\linewidth]{bilder/systemuebersicht}
		\caption{Eine Übersicht der Technologien und wie sie verbunden sind.}
		\label{fig:systemuebersicht}
	\end{figure}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{p{0.1\linewidth} p{0.3\linewidth} p{0.5\linewidth}}
			\textbf{Nr.} & \textbf{Komponente} & \textbf{Beschreibung} \\ \midrule
			1. & Oculus Rift DK2 & \gls{hmd} für den grafischen Output. \\
			2. & Leap Motion & Gerät, welches Hände erkennt und ihre Koordinaten an den Computer sendet. \\
			3. & Oculus Rift Kamera & Kamera, welche seit dem DK2 für das örtliche Tracking zuständig ist. \\
			4. & Computer & Host-System für IMVR. \\
			5. & Benutzer & Benutzer, der die Oculus Rift trägt und mit seinen Händen das Programm steuert. \\
		\end{tabular}
	\end{table}
}

\clearpage

\section{Systemarchitektur}

Zuerst ist es wichtig, zu verstehen, wie die Applikation grob aufgebaut ist. In Abbildung \ref{fig:flow} wird dies in zwei Schritten illustriert.

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{diagramme/flow}
\caption{Grober Überblick des Programmablaufs}
\label{fig:flow}
\end{figure}

Man erkennt wie der Benutzer zuerst ausserhalb der Unity-Applikation den Indexer startet und durchlaufen lässt. Dieser durchläuft alle Ordner, die er in einer \textit{folders.txt} findet und schreibt diese in die Datenbank. Im nächsten Schritt werden aus diversen Quellen weitere Daten abgerufen.

Was ebenfalls auf der Grafik zu sehen ist, sind die Atlasse. Um Ressourcen zu sparen (siehe Kapitel \ref{subsec:resources}), werden alle Bilder in sogenannten Atlassen, sprich Bildersammlungen, gespeichert. Die Bilder, von denen hier die Rede ist, sind Fotos der Artisten und das Artwork der indexierten Alben. 

Sobald die Datenbank im ersten Schritt erstellt wurde, setzt der Anwender, wie in Kapitel \ref{sec:sysoverview} beschrieben, seine Oculus Rift mit dem Leap Motion Aufsatz auf und startet IMVR. Er erhält dann die Auswahl, welchen Modus er beschreiten will und je nach Wahl entsprechende weitere Optionen.



\section{Systemdesign}

Jetzt, wo das grobe Zusammenspiel der Elemente im System klar geworden ist, soll ein bisschen näher auf die Unterelemente eingegangen werden. Aufgrund der Brückenfunktion und deshalb der globalen Relevanz, wird zuerst ein Blick auf die Klassenstruktur der Datenbank geworfen. Danach wird der Aufbau des Indexers untersucht, und zuletzt schliesslich die eigentliche Applikation.

\subsection{Commons (Datenbank)}

Um Daten zwischen den zwei Programmteilen zu transportieren, wurde noch ein weiteres Projekt erstellt mit einer eigenen Datenstruktur, welche in Abbildung \ref{fig:Indexer-Commons-1} ersichtlich ist.

\afterpage {
	\begin{figure}[t!]
		\centering
		\includegraphics[width=1\linewidth]{diagramme/IMVR.Commons-UML.pdf}
		\caption{Klassendiagramm für die Klassen im IMVR.Commons Package}
		\label{fig:Indexer-Commons-1}
	\end{figure}
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{ l X }
			\noalign{\smallskip} \hline \hline \noalign{\smallskip}
			\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
			Artist & Klasse für einen einzelnen Artisten mit Biografie und ein paar Kennwerten sowie Koordinaten und Aktivitätsdaten. \\
			Album & Jeder Artist hat ein oder mehrere Alben, an denen er beteiligt ist. Das Album selbst hat nur ein Name und ein Jahr und kann zu mehreren Künstlern gehören.\\
			Song & Repräsentiert einen Song und gehört genau einem Künstler. Jeder Song hat einen Pfad und ist somit von einer reellen Datei gestützt. Ein Song erhält zusätzlich verschieden Kennwerte, die von Services heruntergeladen werden. \\
			TermItem & Ein Begriff (z.B. Genre), der einem Künstler mit einem Gewicht und einer Frequenz zugeordnet wird. Könnte noch weiter normalisiert werden, wurde aber der Einfachheit halber so gelassen.\\
			AtlasTicket & Repräsentiert eine Position bzw. ein Bild in einem Atlas. Mit der Position ist gemeint, an welcher Stelle das Bild im Atlas erscheint.\\
			IMDB & Zentraler Zugangsknoten zu den Daten. Hält Referenzen auf die Artisten, Songs und Atlasse. \\
			\noalign{\smallskip} \hline \noalign{\smallskip}
		\end{tabularx}
		\caption{Erklärung der wichtigsten allgemeinen Klassen}
		\label{tab:commons}
	\end{table}
}

\clearpage

Es handelt sich um ein bewusst sehr minimalistisch gehaltenes Schema, um eine Musiksammlung darzustellen. Zu den Problemen, die nicht abgedeckt werden gehören zum Beispiel:

\begin{itemize}
	\item Jede Ausgabe eines Liedes gilt als ein separates Lied
	\item Für kombinierte Artisten (z.B. A feat. B) wird jeweils ein neuer Artist erstellt
	\item Mehrere Aktivitätsperioden eines Künstlers können nicht abgebildet werden
\end{itemize}

Es gäbe keine Grenzen, wenn man eine perfekte Struktur erreichen wollte, und das liegt ausserhalb des Bereichs dieses Projektes.


\begin{landscape}
	\subsection{Indexer}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{diagramme/IMVR.Indexer-UML}
		\caption{Klassendiagramm des Indexers}
		\label{uml:IMVR.Indexer}
	\end{figure}
\end{landscape}

Der Indexer basiert auf Nodes. Das Konzept wird dabei mithilfe eines Producer-Consumer Patterns abgebildet.

Alle Nodes im System führen eine Aufgabe auf einem oder mehreren Threads durch. Wenn diese einen Input haben, implementieren sie \code{IConsumer} oder eine der abstrakten Implementationen davon, und wenn diese einen Output haben, implementieren sie \code{IProducer}, um die Daten an den nächsten Node weiterzugeben.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		Options & Singleton-Klasse, welche mit den Command-Args gebildet wird und die Konfigurationen beinhält.\\
		IProducer & Ein Produzent von Daten ($\rightarrow$ Output-Knoten)\\
		IConsumer & Ein Konsument von Daten ($\rightarrow$ Input-Knoten)\\
		AbstractWorker & Jede Node erbt von dieser Klasse. Sie sorgt dafür, dass die Nodes auf eine einheitliche Weise initialisiert, durchgeführt und aufgeräumt werden können.\\
		ConsumerNode & Hilfsklasse, welche IConsumer implementiert und mithilfe einer Methode \code{ProcessItem} den Einsatz erleichtert.\\
		DualNode & Hat die gleiche Funktion wie eine \code{ConsumerNode}, aber implementiert zusätzlich \code{IProducer} und bietet mit \code{Publish} ebenfalls eine Hilfsmethode an.\\
		EchoNestNode & Holt Daten aus der The Echo Nest API und schreibt diese in die Datenbank.\\
		LastFmNode & Holt Daten aus der Last.fm API und schreibt diese in die Datenbank. \\
		MusicIndexer & Konsumiert Files und extrahiert daraus Artisten, Alben und Songs. \\
		FileWalker & Durchläuft die Medienordner und findet Musik und Bilder. \\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der wichtigsten Klassen des Indexers}
	\label{tab:IMVR.Indexer}
\end{table}

\subsection{IMVR}

Nun, da das Design des Indexers festgelegt ist, bedarf auch die Hauptapplikation einer Erklärung. Um das Design besser verdaulich zu machen, wurde hierbei das Schema in verschiedene, logische Teilbereiche gegliedert, die auch den Namespaces des Projekts entsprechen.

Es wird empfohlen, diese Schemas zusammen mit den Erklärungen in Kapitel \ref{chap:implementation_imvr} zu verwenden.

\begin{landscape}
	\subsubsection{Interface}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{diagramme/IMVR.Interface-UML}
		\caption{Klassendiagramm des Interfaces der Applikation (View-Behavior)}
		\label{uml:IMVR.Interface}
	\end{figure}
\end{landscape}

Das Interface von IMVR basiert auf sogenannten \textit{Views}. Zu jedem Zeitpunkt der Applikation ist irgendeine View aktiv, die verantwortlich für die momentane Darstellung der Szene ist.

Die Views gehören und werden kontrolliert vom momentan aktiven \textit{Mode}, wovon zwei existieren: der \code{BrowseMode} und der \code{ListenMode}. Der aktuelle Modus wird verwaltet durch die Klasse \code{ModeController}. Das Wechseln des Modus ist Aufgabe des Ring-Panels und wird in einem separaten Kapitel behandelt.

Ein weiteres relevantes Detail ist das \textit{Theme}, welches den Modi zugeordnet wird. Dieses Theme enthält eine Anzahl von Farben, die später von anderen GUI-Elementen verwendet werden und für eine leichtere Unterscheidung des momentanen Modus sorgen sollen.

\begin{landscape}
	\subsubsection{Music Arm}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{diagramme/IMVR.Interface.MusicArm-UML}
		\caption{Klassendiagramm des Music Arms}
		\label{uml:IMVR.Interface.MusicArm}
	\end{figure}
\end{landscape}

\subsubsection{Ring Panel}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.Interface.RingPanel-UML}
	\caption{Klassendiagramm des Ring Panels, womit der Anwender Modi auswählt}
	\label{uml:IMVR.Interface.RingPanel}
\end{figure}

\subsubsection{Daten}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.Data-UML}
	\caption{Klassendiagramm des Teils, der die Daten der Datenbank verwendet}
	\label{uml:IMVR.Data}
\end{figure}


\subsubsection{Effekte}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.FX-UML.pdf}
	\caption{Klassendiagramm der Effekte und prozeduralen Meshes}
	\label{uml:IMVR.FX}
\end{figure}


\subsubsection{Gesten}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.Gestures-UML}
	\caption{Klassendiagramm des Abstraktionslayers für die Leap Motion}
	\label{uml:IMVR.Gestures}
\end{figure}

