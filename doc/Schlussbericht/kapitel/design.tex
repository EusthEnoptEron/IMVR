\chapter{Design}

Bei der Entwicklung wurden diverse Design-Entscheidungen gefällt, welche zum Teil bereits in einem Vorprojekt analysiert wurden. Diese sollen in diesem Kapitel aufgelistet und erläutert werden.

\section{Systemübersicht}
\label{sec:sysoverview}
Um die Applikation zu bedienen, setzt der Anwender die Oculus Rift auf und bewegt sich im von der mitgelieferten Kamera erkennbaren Bereich.

Die Leap Motion wird prinzipiell so verwendet, wie von der Herstellerfirma vorgesehen. Das heisst, diese wird mit dem offiziellen Aufsatz \cite{leap} an der Oculus Rift befestigt, und deckt so den frontalen Sichtbereich des Anwenders ab. Dies lässt sich gut auf Abbildung \ref{fig:systemuebersicht} erkennen.

Ebenfalls erkennbar ist, dass beide Geräte per USB mit dem Host-Computer verbunden sind und Daten an die jeweiligen Services schicken. Diese Services werden durch die in Unity verwendeten Plugins angesteuert, und die ausgewerteten Daten in IMVR verwendet.

\afterpage {
	\begin{figure}[t!]
		\centering
		\includegraphics[width=0.8\linewidth]{bilder/systemuebersicht}
		\caption{Eine Übersicht der Technologien und wie sie verbunden sind.}
		\label{fig:systemuebersicht}
	\end{figure}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{p{0.1\linewidth} p{0.3\linewidth} p{0.5\linewidth}}
			\textbf{Nr.} & \textbf{Komponente} & \textbf{Beschreibung} \\ \midrule
			1. & Oculus Rift DK2 & \gls{hmd} für den grafischen Output. \\
			2. & Leap Motion & Gerät, welches Hände erkennt und ihre Koordinaten an den Computer sendet. \\
			3. & Oculus Rift Kamera & Kamera, welche seit dem DK2 für das örtliche Tracking zuständig ist. \\
			4. & Computer & Host-System für IMVR. \\
			5. & Benutzer & Benutzer, der die Oculus Rift trägt und mit seinen Händen das Programm steuert. \\
		\end{tabular}
	\end{table}
}

\clearpage

\section{Systemarchitektur}

\subsection{Grober Ablauf}
Zunächst ist es wichtig, zu verstehen, wie die Applikation grob aufgebaut ist. In Abbildung \ref{fig:flow} wird dies in zwei Schritten illustriert.


\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{diagramme/flow}
\caption{Grober Überblick des Programmablaufs}
\label{fig:flow}
\end{figure}

Man erkennt wie der Benutzer zuerst ausserhalb der Unity-Applikation den Indexer startet und durchlaufen lässt. Dieser durchläuft alle Ordner, die er in einer \textit{folders.txt} findet und schreibt diese in die Datenbank. Im nächsten Schritt werden aus diversen Quellen weitere Daten abgerufen.

Was ebenfalls auf der Grafik zu sehen ist, sind die Atlasse. Um Ressourcen zu sparen (siehe Kapitel \ref{subsec:resources}), werden alle Bilder in sogenannten Atlassen, sprich Bildersammlungen, gespeichert. Die Bilder, von denen hier die Rede ist, sind Fotos der Artisten und das Artwork der indexierten Alben. 

Sobald die Datenbank im ersten Schritt erstellt wurde, setzt der Anwender, wie in Kapitel \ref{sec:sysoverview} beschrieben, seine Oculus Rift mit dem Leap Motion Aufsatz auf und startet IMVR. Er erhält dann die Auswahl, welchen Modus er beschreiten will und je nach Wahl entsprechende weitere Optionen.

\subsection{Ablauf von IMVR}

Abbildung \ref{fig:IMVR-Flow} liefert einen genaueren Einblick in den Programmfluss von IMVR. Im Zentrum steht ganz klar die Wahl des Modus, welche grundsätzlich zu jedem Zeitpunkt der Applikation getätigt werden kann. Auch beendet wird die Applikation bei dieser Verzweigung. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{diagramme/IMVR-Flow}
	\caption{Linearer Ablauf von IMVR}
	\label{fig:IMVR-Flow}
\end{figure}


\section{Systemdesign}

Jetzt, wo das grobe Zusammenspiel der Elemente im System klar geworden ist, soll ein bisschen näher auf die Unterelemente eingegangen werden. Aufgrund der Brückenfunktion und deshalb der globalen Relevanz, wird zuerst ein Blick auf die Klassenstruktur der Datenbank geworfen. Danach wird der Aufbau des Indexers untersucht, und zuletzt schliesslich die eigentliche Applikation.


Zu beachten: Die meisten Klassen in den folgenden UML-Diagrammen sind Unity-Komponenten und erben somit von der Klasse  \code{MonoBehaviour}. Um die Diagramme lesbar zu halten, wurde diese Beziehung oft ignoriert. Weiterhin wurden manche C\#-Properties als "get\_Property" und "set\_Property" ausgeschrieben, wo zusätzliche Logik vorhanden ist.

\subsection{Commons (Datenbank)}

Um Daten zwischen den zwei Programmteilen zu transportieren, wurde noch ein weiteres Projekt erstellt mit einer eigenen Datenstruktur, welche in Abbildung \ref{fig:Indexer-Commons-1} ersichtlich ist.

\afterpage {
	\begin{figure}[t!]
		\centering
		\includegraphics[width=1\linewidth]{diagramme/IMVR.Commons-UML.pdf}
		\caption{Klassendiagramm für die Klassen im IMVR.Commons Package}
		\label{fig:Indexer-Commons-1}
	\end{figure}
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{ l X }
			\noalign{\smallskip} \hline \hline \noalign{\smallskip}
			\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
			Artist & Klasse für einen einzelnen Artisten mit Biografie und ein paar Kennwerten sowie Koordinaten und Aktivitätsdaten. \\
			Album & Jeder Artist hat ein oder mehrere Alben, an denen er beteiligt ist. Das Album selbst hat nur ein Name und ein Jahr und kann zu mehreren Künstlern gehören.\\
			Song & Repräsentiert einen Song und gehört genau einem Künstler. Jeder Song hat einen Pfad und ist somit von einer reellen Datei gestützt. Ein Song erhält zusätzlich verschieden Kennwerte, die von Services heruntergeladen werden. \\
			TermItem & Ein Begriff (z.B. Genre), der einem Künstler mit einem Gewicht und einer Frequenz zugeordnet wird. Könnte noch weiter normalisiert werden, wurde aber der Einfachheit halber so gelassen.\\
			AtlasTicket & Repräsentiert eine Position bzw. ein Bild in einem Atlas. Mit der Position ist gemeint, an welcher Stelle das Bild im Atlas erscheint.\\
			IMDB & Zentraler Zugangsknoten zu den Daten. Hält Referenzen auf die Artisten, Songs und Atlasse. \\
			\noalign{\smallskip} \hline \noalign{\smallskip}
		\end{tabularx}
		\caption{Erklärung der wichtigsten allgemeinen Klassen}
		\label{tab:commons}
	\end{table}
}

\clearpage

Es handelt sich um ein bewusst sehr minimalistisch gehaltenes Schema, um eine Musiksammlung darzustellen. Zu den Problemen, die nicht abgedeckt werden gehören zum Beispiel:

\begin{itemize}
	\item Jede Ausgabe eines Liedes gilt als ein separates Lied
	\item Für kombinierte Artisten (z.B. A feat. B) wird jeweils ein neuer Artist erstellt
	\item Mehrere Aktivitätsperioden eines Künstlers können nicht abgebildet werden
\end{itemize}

Es gäbe keine Grenzen, wenn man eine perfekte Struktur erreichen wollte, und das liegt ausserhalb des Bereichs dieses Projektes.


\begin{landscape}
	\subsection{Indexer}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{diagramme/IMVR.Indexer-UML}
		\caption{Klassendiagramm des Indexers}
		\label{uml:IMVR.Indexer}
	\end{figure}
\end{landscape}

Der Indexer basiert auf Nodes. Das Konzept wird dabei mithilfe eines Producer-Consumer Patterns abgebildet.

Alle Nodes im System führen eine Aufgabe auf einem oder mehreren Threads durch. Wenn diese einen Input haben, implementieren sie \code{IConsumer} oder eine der abstrakten Implementationen davon, und wenn diese einen Output haben, implementieren sie \code{IProducer}, um die Daten an den nächsten Node weiterzugeben.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		Options & Singleton-Klasse, welche mit den Command-Args gebildet wird und die Konfigurationen beinhält.\\
		IProducer & Ein Produzent von Daten ($\rightarrow$ Output-Knoten)\\
		IConsumer & Ein Konsument von Daten ($\rightarrow$ Input-Knoten)\\
		AbstractWorker & Jede Node erbt von dieser Klasse. Sie sorgt dafür, dass die Nodes auf eine einheitliche Weise initialisiert, durchgeführt und aufgeräumt werden können.\\
		ConsumerNode & Hilfsklasse, welche IConsumer implementiert und mithilfe einer Methode \code{ProcessItem} den Einsatz erleichtert.\\
		DualNode & Hat die gleiche Funktion wie eine \code{ConsumerNode}, aber implementiert zusätzlich \code{IProducer} und bietet mit \code{Publish} ebenfalls eine Hilfsmethode an.\\
		EchoNestNode & Holt Daten aus der The Echo Nest API und schreibt diese in die Datenbank.\\
		LastFmNode & Holt Daten aus der Last.fm API und schreibt diese in die Datenbank. \\
		MusicIndexer & Konsumiert Files und extrahiert daraus Artisten, Alben und Songs. \\
		FileWalker & Durchläuft die Medienordner und findet Musik und Bilder. \\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der wichtigsten Klassen des Indexers}
	\label{tab:IMVR.Indexer}
\end{table}

\subsection{IMVR}

Nun, da das Design des Indexers festgelegt ist, bedarf auch die Hauptapplikation einer Erklärung. Um das Design besser verdaulich zu machen, wurde hierbei das Schema in verschiedene, logische Teilbereiche gegliedert, die auch den Namespaces des Projekts entsprechen.

Es wird empfohlen, diese Schemas zusammen mit den Erklärungen in Kapitel \ref{chap:implementation_imvr} zu verwenden.

\begin{landscape}
	\subsubsection{Interface}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{diagramme/IMVR.Interface-UML}
		\caption{Klassendiagramm des Interfaces der Applikation (View-Behavior)}
		\label{uml:IMVR.Interface}
	\end{figure}
\end{landscape}

Das Interface von IMVR basiert auf sogenannten \textit{Views}. Zu jedem Zeitpunkt der Applikation ist irgendeine View aktiv, die verantwortlich für die momentane Darstellung der Szene ist.

Die Views gehören und werden kontrolliert vom momentan aktiven \textit{Mode}, wovon zwei existieren: der \code{BrowseMode} und der \code{ListenMode}. Der aktuelle Modus wird verwaltet durch die Klasse \code{ModeController}. Das Wechseln des Modus ist Aufgabe des Ring-Panels und wird in einem separaten Kapitel behandelt.

Ein weiteres relevantes Detail ist das \textit{Theme}, welches den Modi zugeordnet wird. Dieses Theme enthält eine Anzahl von Farben, die später von anderen GUI-Elementen verwendet werden und für eine leichtere Unterscheidung des momentanen Modus sorgen sollen.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		ModeController & Führt Buch über den momentan aktiven Modus.\\
		Mode & Verfügt über einen eigenen Stack von Views, durch die der Anwender navigiert.\\
		BrowseMode & Modus, in dem der Anwender gezielt durch seine Musiksammlung navigiert, indem ihm eine Übersicht aller Künstler angezeigt wird. Beginnt mit der View \code{ArtistOverView}.\\
		ListenMode & Modus, in dem der Anwender nur die Art der Musik angibt, die er hören will. Die Applikation übernimmt den Rest. Beginnt mit der View \code{SelectorView}.\\
		Theme & Eine Sammlung von Farben, die einem Modus zugeordnet wird.\\
		View & Eine ``Ansicht'', die aktiviert und deaktiviert sowie nach vorne und nach hinten geschoben werden kann.\\
		ArtistOverView & Stellt einen gruppierten Zylinder mit den Künstlern in der Musiksammlung dar. \\
		ArtistView & Stellt einen einzelnen Artisten und seine Alben dar. \\
		SelectorView & Stellt ein Auswahlwerkzeug dar, mit dem der Anwender eine Musikart selektieren kann.\\
		ListenView & Verwaltet die visuellen Effekte beim Hören von Musik im Listen-Mode.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der wichtigsten Interface-Klassen}
	\label{tab:IMVR.Interface}
\end{table}

\begin{landscape}
	\subsubsection{Music Arm}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{diagramme/IMVR.Interface.MusicArm-UML}
		\caption{Klassendiagramm des Music Arms}
		\label{uml:IMVR.Interface.MusicArm}
	\end{figure}
\end{landscape}

Das eigentliche Menü, der \textit{Music Arm}, befindet sich im IMVR.Interface.MusicArm Namespace. Er verwaltet die momentan abzuspielende Musik und die selektierten Lieder.

Beim Design der Klassen war ursprünglich ein viel allgemeinerer Ansatz für den Music Arm geplant. Konkret gesagt, wurden die Klassen so gestaltet, dass das Ring-Menü, welches zum Einsatz kommt, im Editor für \textit{irgendeine} Aufgabe konfiguriert werden kann.

In einem gewissen Stadium des Projekts wurde jedoch der Music Arm konzipiert und das Ring-Menü stark umstrukturiert. Neu erhält jede View beim Laden die Möglichkeit, mithilfe der Helper-Klasse \code{RingMenuBuilder} ein eigenes Menü zu gestalten, wobei die Belegung des Zeige-, Mittel- und Ringfingers vorgegeben ist.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		RingMenu & Die zentrale Klasse des Music Arms und gleichzeitig auch die Root-Ebene des Menüs. Existiert nur einmal, verwaltet, welche Stufe momentan angezeigt wird, und sorgt für das Anzeigen und Verstecken des Menüs.\\
		RingMenuItem & Ein einzelner Menüeintrag im Menü. Platziert sich m den entsprechenden Finger wenn sichtbar und hat einen Event-Handler für Click-Events (in diesem Fall Auswahl des Menüs).\\
		IRingMenu & Interface für Menüs mit Einträgen.\\
		RingSubMenu & Implementiert \code{IRingMenu} und funktioniert wie RingMenu, nur ist es selbst auch ein Eintrag in einem anderen \code{IRingMenu}.\\
		RingMenuBuilder & Hilft beim dynamischen Erstellen von neuen Menüeinträgen.\\
		ArmWear & Beschreibt eine Komponente, die am Arm ``getragen'' werden kann.\\
		JukeboxView & Zeigt das momentane Lied in der Jukebox an und wird auf der Frontseite des Arms getragen.\\
		PlaylistView & Zeigt die momentan Playlist an und befindet sich auf der Rückseite des Arms.\\
		Selector & Hilft Komponenten, die im Ring-Menü eine Songselektion machen wollen, dabei.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der wichtigsten Music-Arm-Klassen}
	\label{tab:IMVR.Interface.MusicArm}
\end{table}


\subsubsection{Ring Panel}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{diagramme/IMVR.Interface.RingPanel-UML}
	\caption{Klassendiagramm des Ring Panels, womit der Anwender Modi auswählt}
	\label{uml:IMVR.Interface.RingPanel}
\end{figure}

Das Ring-Panel befindet sich unter den Füssen des Anwenders und wird mit dem Blick bedient. In diesem Namespace befinden sich nur die Klassen, die für die Logik zuständig sind - der visuelle Teil ist bei den Effekten (IMVR.FX) zu finden.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		RingActivator & Abstrakte Klasse, die visuell von einem sich füllenden Ring-Mesh dargestellt wird, und beim anhaltenden Blick aktiviert wird.\\
		ModeActivator & Eine Unterklasse des \code{RingActivator}s, die nur dazu zuständig ist, einen Modus zu aktivieren (siehe \textit{IMVR.Interface}). \\
		ExitActivator & Ein weiterer Activator, der beim Aktivieren die Applikation beendet.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der Klassen des Ring-Panels}
	\label{tab:IMVR.Interface.RingPanel}
\end{table}


\subsubsection{Daten}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.Data-UML}
	\caption{Klassendiagramm des Teils, der die Daten der Datenbank verwendet}
	\label{uml:IMVR.Data}
\end{figure}

Die Klassen, die sich mit den Daten aus der Datenbank bzw. der Darstellung dieser beschäftigen, befinden sich im Namespace \textit{IMVR.Data}.

Der Namespace ist gegliedert in \textit{Data}, \textit{Data.Music} und \textit{Data.Image}. Ersterer befasst sich mit der generellen Darstellung der Daten, der zweite kümmert sich um das Arbeiten mit Musik, und \textit{Data.Image} schliesslich um Aufgaben mit Bildern.

Ursprünglich war geplant, einen Modus nur für die Bilderbibliothek des Anwenders zu entwickeln, und die dabei verwendeten Klassen in den entsprechenden Namespace zu platzieren. Eine Grosszahl dieser Klassen wurde jedoch zusammen mit dem Modus selbst gestrichen. Übrig geblieben sind die Klassen, die noch Verwendung bei der Musik finden (z.B. für das Darstellen von Artwork).

Die allgemeinen Klassen in IMVR.Data enthalten designmässig zum Teil ebenfalls Überbleibsel aus dem Entwicklungsstadium, wo ein separater Bildermodus geplant war. Hauptsächlich zeigt sich das beispielsweise beim \code{CylinderRaycaster}. Dessen Aufgabe war ursprünglich, die grosse Anzahl Bilder handhabbar zu machen, weil einzelnes Raycasting zu viel Zeit beanspruchen würde.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		CylinderLayout & Komponente für die allgemeine Darstellung von GameObjects in einem Zylinder-Layout. Kann per \code{CylinderInteractor} rotiert werden und verfügt über einen optimierten Raycaster.\\
		GroupedCylinderLayout & Ein spezielles \code{CylinderLayout}, welches die Elemente gruppiert mit jeweils einem Label darstellt.\\
		SimpleGroupedCylinderLayout & Ein gruppiertes \code{CylinderLayout}, welches auf normale GameObjects spezialisiert ist.\\
		ListGroupedCylinderLayout & Ein gruppiertes \code{CylinderLayout}, welches auf Listen von Canvas-GameObjects spezialisiert ist.\\
		CylinderInteractor & Kümmert sich um die User-Interaktion mit dem Layout. Hilft beim Rotieren und vertikalen Scrollen. \\
		CylinderRaycaster & Sorgt für ein effizientes Raycasting der Elemente im Layout. Wird wichtig, wenn über 100 interaktive Elemente im Zylinder verteilt sind.\\
		BufferedList & Hilft bei der effizienten Darstellung der Playlist (siehe Kapitel \ref{subsec:performance}).\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der wichtigsten Klassen von IMVR.Data}
	\label{tab:IMVR.Interface.Data}
\end{table}

Der Teil, der für die Bilder zuständig ist, enthält drei Klassen: eine Helper-Klasse, die auf einer hohen Ebene für das einfache Laden von Atlassen aus IMVR.Commons sorgt, eine intelligente Klasse zum Laden von Bildern und eine tiefe Klasse, welche direkt mit den Daten der Atlasse arbeitet.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		AtlasHelper & Hilft beim Laden von Atlassen aus der Datenbank, indem er logische Methoden fürs Laden liefert. Gibt zudem Auskunft über die aktiven Ladevorgänge.\\
		DeferredLoader & Lädt und verwaltet Atlasse vom Filesystem, und liefert Texturen und Sprites für den Zugriff darauf.\\
		TextureAtlas & Ein einzelner Texturenatlas auf dem Filesystem mit einer bestimmten Kachelgrösse.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der Klassen von IMVR.Data.Image}
	\label{tab:IMVR.Interface.Data.Image}
\end{table}

Im Namespace für die Musik gibt es grob gesagt zwei Arten von Klassen: die Jukebox und die Klassen zur Darstellung von Musikdaten.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		Jukebox & Kontrolliert die momentane Wiedergabe und reagiert auf Events der Playlist.\\
		Playlist & Eine Liste von Songs, die für die Wiedergabe vorgesehen sind. Hat eine momentane Selektion, die geändert werden kann. Sender Events beim Ändern der Liste bzw. der momentanen Selektion.\\
		SongItem & Zeigt ein Lied an. \\
		PlaylistSongItem & Zeigt ein Lied an, optimiert für die Anzeige in \code{PlaylistView}.\\
		SongMetaChart & Steuert die FX-Klasse \code{PointChart} um damit Songmetriken dreidimensional darzustellen (siehe Kapitel \ref{subsec:pointchart}) \\
		SongSelection & Enthält eine Ansicht auf die Musikdaten, die durch Auswahlbereiche in verschiedenen MetaGroups eingeschränkt ist. Jede MetaGroup ist ein Kriterium mit einem Wert im Bereich $[0..1]$.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der wichtigsten Klassen von IMVR.Data.Music}
	\label{tab:IMVR.Interface.Data.Music}
\end{table}

\subsubsection{Effekte}
\label{sec:IMVR.FX}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.FX-UML.pdf}
	\caption{Klassendiagramm der Effekte und prozeduralen Meshes}
	\label{uml:IMVR.FX}
\end{figure}

Der visuelle Aspekt der Applikation ist im Namespace \textit{IMVR.FX} aufbewahrt. Hier befinden sich die prozeduralen Meshes und die Partikelsysteme. Was man hier nicht finden wird, sind die visuellen Elemente, die direkt für das Interface verwendet werden. Die Klassen in \textit{IMVR.FX} haben eine unterstützende Funktion.

Auch in diesem Namespace gibt es Klassen in leicht unterschiedlichen Anwendungsszenarios. In einem Szenario geht es darum, Musik zu visualisieren wie es z.B. ein Musik-Player tut.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		VisualizationHelper & Steht im Mittelpunkt der Musik-Visualisierung. Verwaltet die Sample- und Spektrumdaten, die in Echtzeit aus der Musik gewonnen werden.\\
		SpectrumBar & Ein Mesh, welches je nach Stärke des Signals in einem bestimmten Frequenzbereich, höher steigt bzw. tiefer sinkt.\\
		RingVisualizer & Eine kreisförmige, kontinuierliche Linie, welche die Lautstärke eines Kanals (links oder rechts) darstellt.\\
		BeatDetector & Klasse zur Erkennung von Beats in der wiedergegebenen Musik.\\
		Pulsator & Komponente, welche ein Objekt im Takt der Musik pulsieren lässt.\\
		WaveEmitter & Sendet im Takt der Musik Wellen in entsprechender Stärke aus (siehe Kapitel \ref{subsec:waves})\\
		ParticleSpitter & Wirft im Takt der Musik Partikel in die Szene.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der FX-Klassen, die sich mit der Musik-Visualisierung befassen}
	\label{tab:IMVR.FX-Music}
\end{table}

Neben diesen Visualisierungsklassen gibt es auch Komponenten, die sich mit Effekten befassen, die nicht von der momentanen Musik abhängen.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
		RingMesh & Ein zweidimensionales Mesh, welches einen beliebigen Kreisring darstellen kann (siehe Kapitel \ref{subsec:waves}).\\
		FillableRing & Erweitert ein Ring-Mesh mit einer Füllung, die mit der Property \code{Fill} auf einen Wert im Bereich $[0..1]$ eingestellt werden kann.\\
		PointChart & Stellt ein dreidimensionales Point-Chart dar, welches auf Partikel aufbaut (siehe Kapitel \ref{subsec:pointchart}).\\
		HandParticleController & Kontrolliert die Positionen und Bewegungen der Partikel einer Handseite (siehe Kapitel \ref{subsec:handfx}). \\
		ParticleMapping & Mappt einen Partikel auf eine Kombination aus zwei Vertices.\\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
	\caption{Erklärung der allgemeinen FX-Klassen}
	\label{tab:IMVR.FX-General}
\end{table}

\subsubsection{Gesten}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{diagramme/IMVR.Gestures-UML}
	\caption{Klassendiagramm des Abstraktionslayers für die Leap Motion}
	\label{uml:IMVR.Gestures}
\end{figure}

Im Vorprojekt wurde ein Abstraktionslayer für die Hände und Gesten der Leap Motion entwickelt. Dabei wird die in diesem Fall sinnvolle Beschränkung eingeführt, dass nur \textit{eine} linke und \textit{eine} rechte Hand zu jedem gegebenen Zeitpunkt in der Applikation existieren kann.

Ausserdem wird ein einfacher Zugriff auf die Handdaten per \code{HandProvider} möglich, welcher auch ein eigenes System zur Gestenerkennung umfasst. Für eine genauere Detaillierung der Funktionsweise dieses Abstraktionslayers sei auf den Schlussbericht der Vorarbeit verwiesen.

