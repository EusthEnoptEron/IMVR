\chapter{Design}

Bei der Entwicklung wurden diverse Design-Entscheidungen gefällt, welche zum Teil bereits in einem Vorprojekt analysiert wurden. Diese sollen in diesem Kapitel aufgelistet und erläutert werden. 

\section{Systemübersicht}
\label{sec:sysoverview}
Um die Applikation zu bedienen, setzt der Anwender die Oculus Rift auf und bewegt sich im von der mitgelieferten Kamera erkennbaren Bereich.

Die Leap Motion wird prinzipiell so verwendet, wie von der Herstellerfirma vorgesehen. Das heisst, diese wird mit dem offiziellen Aufsatz \cite{leap} an der Oculus Rift befestigt, und deckt so den frontalen Sichtbereich des Anwenders ab. Dies lässt sich gut auf Abbildung \ref{fig:systemuebersicht} erkennen.

Ebenfalls erkennbar ist, dass beide Geräte per USB mit dem Host-Computer verbunden sind und Daten an die jeweiligen Services schicken. Diese Services werden durch die in Unity verwendeten Plugins angesteuert, und die ausgewerteten Daten in IMVR verwendet.

\afterpage {
	\begin{figure}[t!]
		\centering
		\includegraphics[width=0.8\linewidth]{bilder/systemuebersicht}
		\caption{Eine Übersicht der Technologien und wie sie verbunden sind.}
		\label{fig:systemuebersicht}
	\end{figure}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{p{0.1\linewidth} p{0.3\linewidth} p{0.5\linewidth}}
			\textbf{Nr.} & \textbf{Komponente} & \textbf{Beschreibung} \\ \midrule
			1. & Oculus Rift DK2 & \gls{hmd} für den grafischen Output. \\
			2. & Leap Motion & Gerät, welches Hände erkennt und ihre Koordinaten an den Computer sendet. \\
			3. & Oculus Rift Kamera & Kamera, welche seit dem DK2 für das örtliche Tracking zuständig ist. \\
			4. & Computer & Host-System für IMVR. \\
			5. & Benutzer & Benutzer, der die Oculus Rift trägt und mit seinen Händen das Programm steuert. \\
		\end{tabular}
	\end{table}
}

\clearpage

\section{Systemarchitektur}

Zuerst ist es wichtig, zu verstehen, wie die Applikation grob aufgebaut ist. In Abbildung \ref{fig:flow} wird dies in zwei Schritten illustriert.

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{diagramme/flow}
\caption{Grober Überblick des Programmablaufs}
\label{fig:flow}
\end{figure}

Man erkennt wie der Benutzer zuerst ausserhalb der Unity-Applikation den Indexer startet und durchlaufen lässt. Dieser durchläuft alle Ordner, die er in einer \textit{folders.txt} findet und schreibt diese in die Datenbank. Im nächsten Schritt werden aus diversen Quellen weitere Daten abgerufen.

Was ebenfalls auf der Grafik zu sehen ist, sind die Atlasse. Um Ressourcen zu sparen (siehe Kapitel \ref{subsec:resources}), werden alle Bilder in sogenannten Atlassen, sprich Bildersammlungen, gespeichert. Die Bilder, von denen hier die Rede ist, sind Fotos der Artisten und das Artwork der indexierten Alben. 

Sobald die Datenbank im ersten Schritt erstellt wurde, setzt der Anwender, wie in Kapitel \ref{sec:sysoverview} beschrieben, seine Oculus Rift mit dem Leap Motion Aufsatz auf und startet IMVR. Er erhält dann die Auswahl, welchen Modus er beschreiten will und je nach Wahl entsprechende weitere Optionen.



\section{Systemdesign}

Jetzt, wo das grobe Zusammenspiel der Elemente im System klar geworden ist, soll ein bisschen näher auf die Unterelemente eingegangen werden. Aufgrund der Brückenfunktion und deshalb der globalen Relevanz, wird zuerst ein Blick auf die Klassenstruktur der Datenbank geworfen. Danach wird der Aufbau des Indexers untersucht, und zuletzt schliesslich die eigentliche Applikation.

\subsection{Commons (Datenbank)}

Um Daten zwischen den zwei Programmteilen zu transportieren, wurde noch ein weiteres Projekt erstellt mit einer eigenen Datenstruktur, welche in Abbildung \ref{fig:Indexer-Commons-1} ersichtlich ist.

\afterpage {
	\begin{figure}[t!]
		\centering
		\includegraphics[width=1\linewidth]{bilder/Indexer-IMVR-Commons.pdf}
		\caption{Klassendiagramm für die Klassen im IMVR.Commons Package.}
		\label{fig:Indexer-Commons-1}
	\end{figure}
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{ l X }
			\noalign{\smallskip} \hline \hline \noalign{\smallskip}
			\textbf{Klasse} & \textbf{Beschreibung} \\ \midrule
			Artist & Klasse für einen einzelnen Artisten mit Biografie und ein paar Kennwerten sowie Koordinaten und Aktivitätsdaten. \\
			Album & Jeder Artist hat ein oder mehrere Alben, an denen er beteiligt ist. Das Album selbst hat nur ein Name und ein Jahr und kann zu mehreren Künstlern gehören.\\
			Song & Repräsentiert einen Song und gehört genau einem Künstler. Jeder Song hat einen Pfad und ist somit von einer reellen Datei gestützt. Ein Song erhält zusätzlich verschieden Kennwerte, die von Services heruntergeladen werden. \\
			TermItem & Ein Begriff (z.B. Genre), der einem Künstler mit einem Gewicht und einer Frequenz zugeordnet wird. Könnte noch weiter normalisiert werden, wurde aber der Einfachheit halber so gelassen.\\
			AtlasTicket & Repräsentiert eine Position bzw. ein Bild in einem Atlas. Mit der Position ist gemeint, an welcher Stelle das Bild im Atlas erscheint.\\
			IMDB & Zentraler Zugangsknoten zu den Daten. Hält Referenzen auf die Artisten, Songs und Atlasse. \\
			\noalign{\smallskip} \hline \noalign{\smallskip}
		\end{tabularx}
		\caption{Erklärung der wichtigsten Klassen}
		\label{tab:commons}
	\end{table}
}

\clearpage

Es handelt sich um ein bewusst sehr minimalistisch gehaltenes Schema, um eine Musiksammlung darzustellen. Zu den Problemen, die nicht abgedeckt werden gehören zum Beispiel:

\begin{itemize}
	\item Jede Ausgabe eines Liedes gilt als ein separates Lied
	\item Für kombinierte Artisten (z.B. A feat. B) wird jeweils ein neuer Artist erstellt
	\item Mehrere Aktivitätsperioden eines Künstlers können nicht abgebildet werden
\end{itemize}

Es gäbe keine Grenzen, wenn man eine perfekte Struktur erreichen wollte, und das liegt ausserhalb des Bereichs dieses Projektes.

\subsection{Indexer}



\subsection{IMVR}