\chapter{Implementation des Indexers}

Ein Teil der Arbeit war es, einen Indexer zu implementieren, der die Dateien des Benutzers durchläuft und - wie es der Name vermuten lässt - interessante Dateien indexiert. In diesem Kapitel soll auf den Aufbau und die Implementationsdetails eingegangen werden.

\section{Aufbau}

Der Indexer ist als parallelisiertes, knotenbasiertes System konzipiert worden. Die Parallelität wurde deshalb gewählt, weil es beim Einholen der verschiedenen Datenquellen teils zu Wartezeiten kommt, die gut anders genutzt werden können. Dieser Faktor kam besonders ins Spiel als noch zusätzlich zu den Musikdaten auch Bilderdaten gesammelt worden sind.

Ein weiterer Grund für die Parallelisierung ist, dass als mögliches Feature eine real-time Indexierung vorgesehen war, die es letztendlich allerdings nicht in das fertige Programm schaffte. Weitere Informationen zu diesem Thema werden in Abschnitt \ref{sec:indexer:herausforderungen} gegeben.

Der Indexer sowie die Datenstruktur und alle anderen Tools, die eine ergänzende Funktion zur Hauptapplikation haben, wurden in einer separaten Visual Studio Solution zusammengefasst. In dieser befinden sich vier Projekte:

\begin{table}[H]
	\caption{Die Projekte in Auxiliary Tools}
	\centering
	\label{tab:auxiliarytools}
	\begin{tabularx}{\textwidth}{ l X }
		\noalign{\smallskip} \hline \hline \noalign{\smallskip}
		\textbf{Name} & \textbf{Beschreibung} \\ \midrule
		IMVR.Commons & DLL-Projekt, welches die Klassen enthält, die zwischen Applikation und Indexer geteilt werden. \\
		IMVR.Commons.Tests & Testprojekt mit Unit-Tests um die Integrität der Daten sicherzustellen. \\
		IMVR.Indexer & Konsolenprojekt, welches die Musikdateien auf dem Host-System indexiert. \\
		IMVR.SpeechServer & Konsolenprojekt, welches in der Vorarbeit verwendet wurde und in dieser Arbeit keine Verwendung fand. \\
		\noalign{\smallskip} \hline \noalign{\smallskip}
	\end{tabularx}
\end{table}


\section{Datenquellen}

Da IMVR zum Ziel hat, die Musik des Benutzers in verschiedenen Formen und Farben darzustellen, werden Daten von diversen Quellen benötigt. Wir leben in einer wundervollen Zeit in Sachen Datenvielfalt: Es gib viele Online-Services, welche zu einem Grossteil gratis sind, von denen man diverse Daten erhalten kann.

Es folgt eine kurze Zusammenstellung von untersuchten Datenquellen.


\begin{table}[H]
\caption{Eine Übersicht von verfügbaren Online-Datenquellen.}
\centering
\label{t:datasources}
\begin{tabular}{ l l l }
	\noalign{\smallskip} \hline \hline \noalign{\smallskip}
	\textbf{Name} & \textbf{Daten} & \textbf{API-Limite} \\ \midrule
	Last.fm & Bilder, Meta-Daten & 5 Request / Sekunde \\
	The Echo Nest & Bilder, Meta-Daten, Analyse-Daten & 120 Requests / Minute \\
	Spotify & Bilder, Meta-Daten, Playlisten, Streams & ? \\
	Amazon & Bilder, Beschreibungen & 1 Request / Sekunde \\
	Gracenote & Bilder, Fingerprinting, Meta-Daten & $\sim$1000 Requests / Tag \\
	MusicBrainz & Bilder, Meta-Daten & $\sim$1 Request / Sekunde \\
	\noalign{\smallskip} \hline \noalign{\smallskip}
\end{tabular}
\end{table}

Im Falle von IMVR kommen die Daten grundsätzlich von drei verschiedenen Quellen:

\begin{itemize}	
  \item ID3 Tags der Musik-Dateien
  \item The Echo Nest
  \item Last.fm
\end{itemize}

Diese wurden gewählt aufgrund der durchsichtigen API-Limite und den verfügbaren Daten. The Echo Nest aggregiert zudem die Daten von anderen Seiten wie Spotify und MusicBrainz, und enthält wertvolle Analyse-Daten, die in eine zentrale Position in IMVR haben.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\linewidth]{bilder/Indexer-DataFlow.pdf}
\caption{Der Datenfluss, den die Files beim Indexieren nehmen.}
\label{fig:Indexer-DataFlow}
\end{figure}


In einem ersten Schritt werden grundlegende Daten wie der Titel des Liedes, der Name des Artisten, usw. aus der Datei selbst entnommen. Wenn möglich wird auch gleich geprüft, ob ein Album-Cover hinterlegt ist.

In einem zweiten Schritt wird über eine .NET Bibliothek, welche im Rahmen des Projektes geforkt und erweitert wurde, zur API von The Echo Nest verbunden und diverse Meta-Daten zur Musik heruntergeladen.

\section{Datenstruktur}

Für die Abspeicherung der Daten wurde zuerst ein Ansatz gewählt, der auf einer SQLite Datenbank basierte. Diese wurde in einem Prototyp auch erfolgreich implementiert. Es stellte sich jedoch heraus, dass diese Abhängigkeit das Programm unnötig verkomplizieren würde und eine simple In-Memory Datenstruktur völlig ausreicht.

Das finale Produkt verwendet also eine simple, objektorientiert Datenstruktur, die serialisiert und so zwischen den zwei Projekten (Indexer und IMVR) geteilt werden kann. Das Schema ist in Abbildung \ref{fig:Indexer-Commons} zu sehen. Damit beide Projekte Zugriff auf die genutzten Klassen haben, wurde das Schema in eine separate DLL ausgelagert, die ebenfalls als Abhängigkeit in beiden Projekten referenziert wird.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{bilder/Indexer-IMVR-Commons.pdf}
	\caption{Klassendiagramm für die Klassen im IMVR.Commons Package.}
	\label{fig:Indexer-Commons}
\end{figure}

Anzumerken ist, dass mehrere Einstiegspunkte auf die Daten existieren und so eine gewisse Redundanz geschaffen wird. Diese Redundanz ist hilfreich, weil in IMVR mehrere Modi eben diese Einstiegspunkte benötigen. Aufgrund der gewählten Serialisierungsmethode entsteht jedoch kein grosser Speicher-Overhead.

Die Serialisierung wird durch sogenannte Protocol Buffers \cite{wiki:protobufs} realisiert, wofür eine Open-Source Bibliothek namens \textit{protobuf-net} \footnote{\url{https://code.google.com/p/protobuf-net/}} existiert. Protocol Buffers ist ein binäres Datenformat, welches von Google Inc. entwickelt wurde und bekannt ist für seine Kompaktheit und Simplizität. Gewählt wurde es, weil die herkömmliche Serialisierung mit .NETs \code{BinaryFormatter} zum Teil zu Problemen mit Unity führen kann.

\section{Herausforderungen}
\label{sec:indexer:herausforderungen}

Während der Entwicklung des Indexers kristallisierten sich diverse Schwierigkeiten, welche grundsätzlich in drei Kategorien einordnen lassen: organisatorische und datentechnische.

Die Organisation, oder Planung, war deshalb problematisch, weil einer der wichtigsten Faktoren für den Aufbau des Indexers die Vielfalt der Datentypen war. Da anfangs geplant war, Musik \textit{und} Bilder zu indexieren und darzustellen, machte eine parallele Verarbeitung der Daten Sinn und war auch notwendig.

Es wurden parallel mehrere Bilder auf mehreren CPU-Kernen analysiert, und gleichzeitig wurde auch die Musikdatenbank erweitert. Mit dem Wegfall des Bilder-Parts wird die parallele Verarbeitung also um einiges unwichtiger. Dies gilt besonders, weil bei den Datenquellen der Musikindexierung jeweils nur ein Thread Sinn macht, da die APIs mit Limiten ausgestattet sind.

Datentechnisch stellte es sich als problematisch heraus, geeignete Datenquellen zu wählen. Von Anfang an war klar, dass der Service von The Echo Nest verwendet würde, doch dieser alleine ist nicht ausreichend.

Bevor schliesslich Last.fm als Quelle für Album-Covers gewählt wurde, wurden besonders zwei APIs untersucht: Amazon und Gracenote.

Im Falle von Amazon führten zwei Probleme zum Ausschluss: das Fehlen einer guten C\#-Bibliothek und die schwerfällige Registrierung. Momentan sieht die Situation so aus, dass recht viel manuell gemacht werden muss, bzw. eine umfangreiche Service-Description importiert werden muss. \cite{indexer:amazon} In Sachen Registrierung wird erwartet, dass man eine Webseite registriert, Kontaktdaten angibt und dann geprüft wird.

Bei Gracenote beläuft sich das Problem hauptsächlich auf die Daten-Limite. Diese ist nirgends öffentlich ersichtlich, und sobald diese überschritten wird, sind keine Requests mehr möglich für den ganzen Tag. In einer Applikation wie IMVR, wo in einem Schritt alles indexiert werden soll, ist die ein Killer-Kriterium.